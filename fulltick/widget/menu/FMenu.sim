/* 
	Copyright (c) 2018 Azeez Adewale <azeezadewale98@gmail.com"> 
	MIT License Copyright (c) 2018 SIMPLE

*/

/* 
 * @Filename - FMenuBar.sim
 * @Author - Azeez Adewale
 * @Date - 14 March 2018
 * @Time - 05:16 AM
 *
 */

module fulltick.widget

#call the @Class FInput File for blocks inheritance
call "fulltick/core/FWidget.sim" ? fulltick.widget

#This @Class FMenuBar @Skip
#  ________________________________________________________
# |________________________________________________________|
#@EndSkip @Image FMenuBar
class FMenu : FWidget	

	/* TYPES */
	MENU_WIDGET_SELECTION_COLOR = new FColor #the default selection color unimportant
	
	/* INTEGER */
	MENU_WIDGET_DOWN_BOX_TYPE = 2 #declare the default down box type to be flat

	#Add a new menu item to the menu or a menu item itself this block 
	#this block takes both @DataType string and the @Class FMenuItem 
	#as parameter if a string is sent as parameter then the @Link Callback
	#can only be assigned using index on the menu but you when a 
	#@Class FMenuItem is sent as parameter then other fine tunning, 
	#properties and @Link Callback can be assigned to the the class
	#before been sent as parameter to this block.
	#Parameters can be sent as list or single object 
	#@Note It @Returns this which is the widget to allow the in-line usage 
	#of the menu
	block addItem(menuitem)
		try 
			if isList(menuitem) 
				for a = 0 to lengthOf(menuitem)
					addSingleItem(menuitem[a])
				end
			else
				addSingleItem(menuitem)
			end
		catch 
			try 
				addSingleItem(menuitem) 
			catch 
				#addItemRaw(menuitem,null,null,null,null) 
				display __err__
			end
		end
		return this
		
	#@Deprecated
	#add a single menuitem this block does not accept @DataType List as
	#parameter but a single object to dynamically add object call the
	#@Block addItem(menuitem) instead 
	#@Note It @Returns this which is the widget to allow the in-line usage 
	#of the menu
	block addSingleItemDepreciated(menuitem) 
		if (menuitem.isSubMenu()) 
			for a = 0 to lengthOf(menuitem.getItems())
				addItemRaw(menuitem.getItems()[a].getValue(),menuitem.getItems()[a].getShortcut(),menuitem.getItems()[a].getCallback(),menuitem.getItems()[a].getUserData(),menuitem.getItems()[a].getFlag())
			end
		else 
			addItemRaw(menuitem.getValue(),menuitem.getShortcut(),menuitem.getCallback(),menuitem.getUserData(),menuitem.getFlag())
		end
		return this
		
	#Add a list containing all the @Class FMenuItem(s) and the sub menus
	#the list can be just a list of one menu @Code
	#	menu = ["Menu","callback()",MENU_TYPE]
	#@EndCode
	#or it can be a hierarchy of @Class FMenuItem(s) and sub menus of 
	#unlimited size and limit so far it follows the rules e.g @Code
	#menu = [
	#		["File", 
	#			[["New", "new()",[
	#				["Project", "open()"],
	#				["Website", "open()"]]],
	#			["0pen", "open()"],
	#			["Save", "save()"],
	#			["Save As..", "saveAs()"]]			
	#		],
	#		["Search", 
	#			[["Find", "find()"],
	#			["Replace", "replace()"]]		
	#		],
	#		["Run", 
	#			[["Run", "runSource()"],
	#			["Debug", "debugSource()"]]		
	#		],
	#		["About", "about()"]
	#	]
	#@EndCode the summary of what happen above is that the main list ~menu~
	#contains four list **with index[0] the first list "File"  **. Supplying 
	#the menu above each of the list will be taken individually for example
	#the first list @Code
	#menu = [
	#		["File", 
	#			[["New", "new()",[
	#				["Project", "open()"],
	#				["Website", "open()"]]],
	#			["0pen", "open()"],
	#			["Save", "save()"],
	#			["Save As..", "saveAs()"]]			
	#		],..
	#	]
	#@EndCode the submenu File will be added to the menubar since the second
	#option is a list it regard it a a sub menu items which also have a list 
	#at index 2 which will be regarded as a submenu to the New which is a 
	#child menu of File so we have @Code
	#File --> New --> Project
	#			  --> Website
	#@EndCode check the example @Example menudemo.sim for more enlightenment
	block addMenu(menu) 
		subMenu = []
		for a = 0 to lengthOf(menu)  
			if (isList(menu[a]))  
				menuLevelOne = menu[a] menuItemLevelOne = new FMenuItem(menuLevelOne[0]) 
				if (containsChildMenus(menuLevelOne))
					subMenu = menuLevelOne[getSubmenuListIndex()] 
					addMenu(treatMenu(subMenu,menuItemLevelOne))
				else 
					if menuLevelOne[1] != "" || menuLevelOne[1] != 0 menuItemLevelOne.callback(menuLevelOne[1]) end
					try if menuLevelOne[2] != "" || menuLevelOne[2] != 0 menuItemLevelOne.setFlag(menuLevelOne[2]) end catch end
					return addSingleItem(menuItemLevelOne)
				end
			else
				menuItemLevelOne = new FMenuItem(menu[0]) 
				if menu[1] != "" || menu[1] != 0 menuItemLevelOne.callback(menu[1]) end
				try if menu[2] != "" || menu[2] != 0 menuItemLevelOne.setFlag(menu[2]) end catch end
				return addSingleItem(menuItemLevelOne)
			end
		end 
		notifyWidget()
		return this
		
	#Add a menu item to an instance of the @Class FMenu widget this is a
	#safe block as it notify the @FMenuItem widget to do all necessary 
	#treating if you want you can call the @block addItemRaw(value,flag)  
	#directly. This block accept @Class FMenuItem widget as a parameter
	#only any other @Link DATATYPE sent as param is an error
	block addSingleItem(menuitem) 
		addItemRaw(menuitem.getValue(),menuitem.getFlag())
		menuitem.notifyWidget()
		return this
		
	#This is the main block that add item to the widget of @Class FMenuBar
	#instance. Use this block directly if you know what you are doing
	#@Hint using directly can be faster as no formating and treatments
	#is done i.e some safe block formating are skipped @EndHint
	#@Note it not safe use only if you know what you are doing
	block addItemRaw(value,flag) 
		__menu_add(WIDGETPOINTER,value,flag) 
		
	block clear()
		__menu_clear(WIDGETPOINTER,0,0)
		notifyWidget()
		return this
		
	block clearSubmenuAt(index)
		__menu_clear(WIDGETPOINTER,1,index)
		notifyWidget() 
		return this
		
	block setSelectionColor(color)
		try {
			color.getColor() MENU_WIDGET_SELECTION_COLOR = color
		catch
			MENU_WIDGET_SELECTION_COLOR = new FColor
			MENU_WIDGET_SELECTION_COLOR.setColorValue(color)
		}
		__menu_selection_color(WIDGETPOINTER,MENU_WIDGET_SELECTION_COLOR.getColor())
		notifyWidget()
		return this
		
	#This block function is same as @Block setSelectionColor(color)
	block setDownColor(color) return setSelectionColor(color)
	
	block setDownBox(type)
		__menu_selection_color(WIDGETPOINTER,type)
		
	#all the private attributes, fields and block not accessible outside
	#the class
	private 
	
		/* STRING */
		SUBMENU_LIST_INDEX = 2 #the index at which the submenu child menu are

		#This block check a menu item is a submenu and also change the
		#@Attribute SUBMENU_LIST_INDEX to the index of the submenu at which
		#the other sub menu items are located
		#@Note this block is not meant to be called from outside the @Class
		#FMenu o prevent error during runtime
		block containsChildMenus(submenu)
			if (lengthOf(submenu) > 2 && isList(submenu[3])) SUBMENU_LIST_INDEX = 3 return true
			elif (lengthOf(submenu) > 1 && isList(submenu[2])) SUBMENU_LIST_INDEX = 2 return true
			elif (lengthOf(submenu) > 0 && isList(submenu[1])) SUBMENU_LIST_INDEX = 1 return true
			end
			return false
	
		#We don't work to use the @Attribute SUBMENU_LIST_INDEX directly 
		#@Hint usage from block is safe so if the attribute is to be 
		#treated or formated in future it wont break code
		block getSubmenuListIndex()
			return SUBMENU_LIST_INDEX
			
		#Any @Class FMenuItem added to an instance the @Class FMenu if the  
		#parent is a submenu then the value of the widget will have to be 
		#relative to the parent submenu to ensure the menu is added in the proper
		#hierarchy
		#@Return the submenu with formated value @DataType LIST
		block treatMenu(submenu, parentitem)
			for a = 0 to lengthOf(submenu) submenu[a][1] = parentitem.getValue()+"/"+submenu[a][1] end
			return submenu
	
		
		